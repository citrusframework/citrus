[[xml-message-validation]]
== XML validation

XML is a very common message format especially in the SOAP WebServices and JMS messaging world. Citrus provides XML message
validator implementations that are able to compare XML message structures. The validator will notice differences in the XML
message and supports XML namespaces, attributes and XML schema validation.

XML message validation is not enabled by default in your project. You need to add the validation module to your project
as a Maven dependency.

.XML validation module dependency
[source,xml]
----
<dependency>
  <groupId>org.citrusframework.citrus</groupId>
  <artifactId>citrus-validation-xml</artifactId>
  <version>${citrus.version}</version>
</dependency>
----

The default XML message validator implementation is active by default and can be overwritten with a custom implementation
using the bean id *defaultXmlMessageValidator* .

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public DomXmlMessageValidator defaultXmlMessageValidator() {
    return new DomXmlMessageValidator();
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<bean id="defaultXmlMessageValidator" class="org.citrusframework.citrus.validation.xml.DomXmlMessageValidator"/>
----

The default XML message validator is very powerful when it comes to compare XML structures. The validator supports namespaces
with different prefixes and attributes als well as namespace qualified attributes. See the following sections for a detailed
description of all capabilities.

[[xml-payload-validation]]
=== XML payload validation

Citrus is able to verify XML message content on a received message. You as a tester can compare the whole XML message body
to a predefined control message template. The Citrus message validator will walk through the XML document and compare the
elements, attributes and values.

You can define the expected XML message template in multiple ways:

* Defines the message body as nested XML message template in the test code. The whole message body is defined inside the test case.
* Defines an expected XML message template via external file resources. This time the body content is loaded at runtime from the external file.

In Java tests that use the Citrus domain specific language you must use verbose String concatenation when constructing XML
message contents inline. You need to escape reserved characters like quotes and line breaks. This is why you should consider
to using external file resources in Java when dealing with large complex message data.

.Java
[source,java,indent=0,role="primary"]
----
@CitrusTest
public void externalBodyResourceTest() {
    receive("someEndpoint")
        .message()
        .body(new ClassPathResource("org/citrusframework/citrus/message/data/TestRequest.xml"))
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <payload file="classpath:org/citrusframework/citrus/message/data/TestRequest.xml"/>
  </message>
</receive>
----

Inline message body definition or external file resource give us a control message template that the test case expects to
validate. Citrus uses this control template for extended message comparison. All elements, namespaces, attributes and node
values are validated in this comparison. When using XML message bodies Citrus will navigate through the whole XML structure
validating each element and its content.

Only in case received message and control message are equal to each other as expected the message validation will pass. In
case differences occur the test case fails with detailed error message.

Citrus supports various ways to add dynamic message content in the message template. Secondly, Citrus can ignore some elements
that should not be part of message comparison (e.g. when generated content or timestamps are part of the message content).
The tester can enrich the expected message template with test variables or ignore-expressions so we get a more robust
validation mechanism. We will talk about this in the next sections to come.

[[xml-header-validation]]
=== XML header validation

A message can have multiple headers in addition to the body content. You can validate headers with expected name and the
control value. Just add the following header validation to your receiving action.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .header("Operation", "sayHello")
    .header("MessageId", "${messageId}");
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <header>
        <element name="Operation" value="GetCustomer"/>
        <element name="RequestTag" value="${requestTag}"/>
    </header>
  </message>
</receive>
----

Message headers are represented as name-value pairs. Each expected header element identified by its name has to be present
in the received message. In addition to that the header value is compared to the given control value. If a header entry is
not available, or the value does not match the expectations the test raises validation errors.

[[xml-header-fragment-validation]]
=== XML header fragment validation

Sometimes message headers may not apply to the name-value pair pattern. For example SOAP headers can also contain XML
fragments as header values. You can add complex header data as expected value in the validation.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .header("Operation", "SayHello")
    .header("<ns0:HelloHeader xmlns:ns0=\"http://citrusframework.org/schemas/samples/HelloService.xsd\">" +
                "<ns0:MessageId>${messageId}</ns0:MessageId>" +
                "<ns0:CorrelationId>${correlationId}</ns0:CorrelationId>" +
                "<ns0:User>${user}</ns0:User>" +
                "<ns0:Text>Hello from Citrus!</ns0:Text>" +
            "</ns0:HelloHeader>");
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <header>
      <data>
        <![CDATA[
          <ns0:HelloHeader xmlns:ns0="http://citrusframework.org/schemas/samples/HelloService.xsd">
              <ns0:MessageId>${messageId}</ns0:MessageId>
              <ns0:CorrelationId>${correlationId}</ns0:CorrelationId>
              <ns0:User>${user}</ns0:User>
              <ns0:Text>Hello from Citrus!</ns0:Text>
          </ns0:HelloHeader>
        ]]>
      </data>
      <element name="Operation" value="SayHello"/>
    </header>
  </message>
</receive>
----

The header data has not name but uses a complex XML fragment as a value. In SOAP this header fragment will be added as
a `SOAP-ENV:Header` then. Please read more about this in link:#soap-headers[SOAP support].

[[xml-ignore-validation]]
=== Ignore XML elements

Some elements in the message payload might not apply for validation at all. Just think of communication timestamps or dynamic
values that have been generated from a foreign service.

You as a tester may not be able to predict such a timestamp or dynamically value for expected validation. This is why you can
safely ignore elements and attributes in the XML message validation.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .header("<TestMessage>" +
                "<VersionId>${versionId}</VersionId>" +
                "<Timestamp>?</Timestamp>" +
                "<MessageId>?</MessageId>" +
            "</TestMessage>")
    .validate(xpath()
            .ignore("/TestMessage/Timestamp")
            .ignore("/TestMessage/MessageId"));
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <payload>
      <TestMessage>
        <VersionId>${versionId}</VersionId>
        <Timestamp>?</Timestamp>
        <MessageId>?</MessageId>
      </TestMessage>
    </payload>
    <ignore path="/TestMessage/Timestamp"/>
    <ignore path="/TestMessage/MessageId"/>
  </message>
</receive>
----

The receive action above is not able to verify the elements `Timestamp` and `MessageId`. This is because the timestamp uses
milliseconds and the message id has been generated by the server application. Both values must be excluded from XML validation.

You can use ignore XPath expressions that match elements in the message content that should be excluded. XPath expressions can
be cumbersome and error prone though.

You can also use inline *@ignore@* expressions as expected template values in order to exclude elements from valdidation. This
is for those of you that do not like to write XPath expressions. As a result the ignored message elements are automatically
skipped when Citrus compares and validates message contents and do not break the test case.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .header("<TestMessage>" +
                "<VersionId>${versionId}</VersionId>" +
                "<Timestamp>@ignore@</Timestamp>" +
                "<MessageId>@ignore@</MessageId>" +
            "</TestMessage>");
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <payload>
      <TestMessage>
        <VersionId>${versionId}</VersionId>
        <Timestamp>@ignore@</Timestamp>
        <MessageId>@ignore@</MessageId>
      </TestMessage>
    </payload>
  </message>
</receive>
----

Feel free to mix both mechanisms to ignore message elements. Ignore expressions are valid as elements, sub-tree nodes and
attributes. You can use the *@ignore@* placeholder in external file resources, too.

[[xml-xpath-validation]]
=== XPath validation

The section link:#xml-payload-validation[XML payload validation] showed how to validate the complete XML message structure
with control message template. All elements are validated and compared one after another.

In some cases this approach might be too extensive. Imagine the tester only needs to validate a small subset of message elements.
You would rather want to use explicit element validation with XPath.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .validate(xpath()
        .expression("/TestRequest/MessageId", "${messageId}")
        .expression("//VersionId", "2"));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="/TestRequest/MessageId" value="${messageId}"/>
      <xpath expression="/TestRequest/VersionId" value="2"/>
    </validate>
  </message>
</receive>
----

In Java the use of a map may be the easiest way to declare multiple expressions for XPath validation.

.Java DSL
[source,java]
----
final Map<String, Object> expressions = new HashMap<>();
expressions.put("/TestRequest/MessageId", "${messageId}");
expressions.put("//VersionId", "2");

receive("someEndpoint")
    .message()
    .validate(xpath()
        .expressions(expressions));
}
----

Instead of comparing the whole message some message elements are validated explicitly via XPath. Citrus evaluates the XPath
expression on the received message and compares the result value to the control value. The basic message structure as well
as all other message elements are not included into this explicit validation.

NOTE: If this type of element validation is chosen neither <payload> nor <data> nor <resource> template definitions are
allowed in Citrus XML test cases.

TIP: Citrus offers an alternative dot-notated syntax in order to walk through XML trees. In case you are not familiar with
XPath or simply need a very easy way to find your element inside the XML tree you might use this way. Every element hierarchy
in the XML tree is represented with a simple dot - for example:

`TestRequest.VersionId`

The expression will search the XML tree for the respective `<TestRequest><VersionId>` element. Attributes are supported too.
In case the last element in the dot-notated expression is a XML attribute the framework will automatically find it.

Of course this dot-notated syntax is very simple and might not be applicable for more complex tree navigation. XPath is
much more powerful - no doubt. The dot-notated syntax might help those of you that are not familiar with XPath.
So the dot-notation is supported wherever XPath expressions might apply.

The Xpath expressions can evaluate to different result types. By default, Citrus is operating on *NODE* and *STRING* result
types so that you can validate some element value. But you can also use different result types such as *NODESET* and *BOOLEAN* .

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("boolean:/TestRequest/Error", false)
        .expression("number:/TestRequest/Status[.='success']", 3)
        .expression("node-set:/TestRequest/OrderType", "[single, multi, multi]");
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="/TestRequest/Error" value="false" result-type="boolean"/>
      <xpath expression="/TestRequest/Status[.='success']" value="3" result-type="number"/>
      <xpath expression="/TestRequest/OrderType" value="[single, multi, multi]" result-type="node-set"/>
    </validate>
  </message>
</receive>
----

In the example above we use different expression result types. First we want to make sure nor */TestRequest/Error* element
is present. This can be done with a boolean result type and *false* value. Second we want to validate the number of found
elements for the expression */TestRequest/Status[.='success']* . The XPath expression evaluates to a node list that results
in its list size to be checked. And last not least we evaluate to a *node-set* result type where all values in the node list
will be translated to a comma delimited string value.

You can use even more powerful validation expressions with matcher implementations. With validation matchers you are able to
use validations such as *greaterThan*, *lessThan*, *hasSize* and much more.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("/TestRequest/Error", anyOf(empty(), nullValue()))
        .expression("number:/TestRequest/Status[.='success']", greaterThan(0.0))
        .expression("integer:/TestRequest/Status[.='failed']", lowerThan(1))
        .expression("node-set:/TestRequest/OrderType", hasSize(3));
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="/TestRequest/Error" value="@assertThat(anyOf(empty(), nullValue()))@"/>
      <xpath expression="/TestRequest/Status[.='success']" value="@assertThat(greaterThan(0.0))@" result-type="number"/>
      <xpath expression="/TestRequest/Status[.='failed']" value="@assertThat(lowerThan(1))@" result-type="integer"/>
      <xpath expression="/TestRequest/OrderType" value="@assertThat(hasSize(3))@" result-type="node-set"/>
    </validate>
  </message>
</receive>
----

NOTE: The validation matchers used in the example above use the link:#hamcrest-message-validation[citrus-hamcrest-validation]
module.

NOTE: XPath uses decimal number type *Double* by default when evaluating expressions with *number* result type. This means
we have to use Double typed expected values, too. Citrus also provides the result type *integer* that automatically converts
the XPath expression result to a *Integer* type.

When using the XML DSL we have to use the *assertThat* validation matcher syntax for defining the Hamcrest matcher. You can
combine matcher implementation as seen in the *anyOf(empty(), nullValue())* expression. When using the Java DSL you can just
add the matcher as expected result object. Citrus evaluates the matchers and makes sure everything is as expected. This is a
very powerful validation mechanism as it also works with node-sets containing multiple values as list.

This is how you can add very powerful message element validation in XML using XPath expressions.

[[xml-validation-namespaces]]
=== XML namespaces

Namespaces represent an essential concept in XML. A namespace declares an element to be part of a very specific ruleset. You
have to specify namespaces also when using XPath expressions. Let's have a look at an example message that uses XML namespaces:

.Sample XML body with namepaces
[source,xml]
----
<ns1:TestMessage xmlns:ns1="http://citrus.com/namespace">
    <ns1:TestHeader>
        <ns1:CorrelationId>_</ns1:CorrelationId>
        <ns1:Timestamp>2001-12-17T09:30:47.0Z</ns1:Timestamp>
        <ns1:VersionId>2</ns1:VersionId>
    </ns1:TestHeader>
    <ns1:TestBody>
        <ns1:Customer>
            <ns1:Id>1</ns1:Id>
        </ns1:Customer>
    </ns1:TestBody>
</ns1:TestMessage>
----

Now we would like to validate some elements in this message using XPath

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("//TestMessage/TestHeader/VersionId", 2L)
        .expression("//TestMessage/TestHeader/CorrelationId", "${correlationId}");
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="//TestMessage/TestHeader/VersionId" value="2"/>
      <xpath expression="//TestMessage/TestHeader/CorrelationId" value="${correlationId}"/>
    </validate>
  </message>
</receive>
----

The validation will fail although the XPath expression looks correct regarding the XML tree. This is because the message uses the
namespace `xmlns:ns1="http://citrus.com/namespace"`. The XPath expression is not able to find the elements because of the missing
namespace declaration in the expression. The correct XPath expression uses the namespace prefix as defined in the message.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("//ns1:TestMessage/ns1:TestHeader/ns1:VersionId", 2L)
        .expression("//ns1:TestMessage/ns1:TestHeader/ns1:CorrelationId", "${correlationId}");
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="//ns1:TestMessage/ns1:TestHeader/ns1:VersionId" value="2"/>
      <xpath expression="//ns1:TestMessage/ns1:TestHeader/ns1:CorrelationId" value="${correlationId}"/>
    </validate>
  </message>
</receive>
----

Now the expressions works fine, and the validation is successful. Relying on the namespace prefix `ns1` is quite error prone though.
This is because the test depends on the very specific namespace prefix. As soon as the message is sent with a different
namespace prefix (e.g. ns2) the validation will fail again.

You can avoid this effect when specifying your own namespace context and your own namespace prefix during validation.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("//pfx:TestMessage/pfx:TestHeader/pfx:VersionId", 2L)
        .expression("//pfx:TestMessage/pfx:TestHeader/pfx:CorrelationId", "${correlationId}")
        .namespaceContext("pfx", "http://citrus.com/namespace"));
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="//pfx:TestMessage/pfx:TestHeader/pfx:VersionId" value="2"/>
      <xpath expression="//pfx:TestMessage/pfx:TestHeader/pfx:CorrelationId" value="${correlationId}"/>
      <namespace prefix="pfx" value="http://citrus.com/namespace"/>
    </validate>
  </message>
</receive>
----

Now the test is independent of any namespace prefix in the received message. The namespace context will resolve the namespaces
and find the elements although the message might use different prefixes. The only thing that matters is that the namespace
value (http://citrus.com/namespace[http://citrus.com/namespace]) matches.

TIP: Instead of this namespace context on validation level you can also have a global namespace context which is valid in
all test cases. We just add a bean in the basic Spring application context configuration which defines global namespace mappings.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public NamespaceContextBuilder namespaceContext() {
    NamespaceContextBuilder builder = new NamespaceContextBuilder();
    builder.getNamepspaceMappings().put("pfx", "http://www.consol.de/samples/sayHello");
    return builder;
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<namespace-context>
    <namespace prefix="def" uri="http://www.consol.de/samples/sayHello"/>
</namespace-context>
----

Once defined the *def* namespace prefix is valid in all test cases and all XPath expressions. This enables you to free your
test cases from namespace prefix bindings that might be broken with time. You can use these global namespace mappings wherever
XPath expressions are valid inside a test case (validation, ignore, extract).

In the previous section we have seen that XML namespaces can get tricky with XPath validation. Default namespaces can do
even more! So lets look at the example with default namespaces:

.Sample XML body with default namespaces
[source,xml]
----
<TestMessage xmlns="http://citrus.com/namespace">
    <TestHeader>
        <CorrelationId>_</CorrelationId>
        <Timestamp>2001-12-17T09:30:47.0Z</Timestamp>
        <VersionId>2</VersionId>
    </TestHeader>
    <TestBody>
        <Customer>
            <Id>1</Id>
        </Customer>
    </TestBody>
</TestMessage>
----

The message uses default namespaces. The following approach in XPath will fail due to namespace problems.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("//TestMessage/TestHeader/VersionId", 2L)
        .expression("//TestMessage/TestHeader/CorrelationId", "${correlationId}"));
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="//TestMessage/TestHeader/VersionId" value="2"/>
      <xpath expression="//TestMessage/TestHeader/CorrelationId" value="${correlationId}"/>
    </validate>
  </message>
</receive>
----

Even default namespaces need to be specified in the XPath expressions. Look at the following code listing that works fine
with default namespaces:

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
        .expression("//:TestMessage/:TestHeader/:VersionId", 2L)
        .expression("//:TestMessage/:TestHeader/:CorrelationId", "${correlationId}"));
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
  <message>
    <validate>
      <xpath expression="//:TestMessage/:TestHeader/:VersionId" value="2"/>
      <xpath expression="//:TestMessage/:TestHeader/:CorrelationId" value="${correlationId}"/>
    </validate>
  </message>
</receive>
----

TIP: It is recommended to use the namespace context as described in the previous chapter when validating. Only this approach
ensures flexibility and stable test cases regarding namespace changes.

[[customize-xml-parser-and-serializer]]
=== Customize XML parser and serializer

When working with XML data format parsing and serializing is a common task. XML structures are parsed to a DOM (Document
Object Model) representation in order to process elements, attributes and text nodes. DOM node objects get serialized to a
String message payload representation. The XML parser and serializer is customizable to a certain level. By default, Citrus
uses the https://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/[DOM Level 3 Load and Save] implementation with following settings:

.Parser settings
[horizontal]
cdata-sections:: *true*
split-cdata-sections:: *false*
validate-if-schema:: *true*
element-content-whitespace:: *false*

.Serializer settings
[horizontal]
format-pretty-print:: *true*
split-cdata-sections:: *false*
element-content-whitespace:: *true*

The parameters are also described in https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMConfiguration[W3C DOM configuration] documentation. We can customize the default settings by adding
a _XmlConfigurer_ Spring bean to the Citrus application context.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XmlConfigurer xmlConfigurer() {
    XmlConfigurer configurer = new XmlConfigurer();
    configurer.getParseSettings().put("validate-if-schema", false);

    configurer.getSerializeSettings().put("comments", false);
    configurer.getSerializeSettings().put("format-pretty-print", false);
    return configurer;
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<bean id="xmlConfigurer" class="org.citrusframework.citrus.xml.XmlConfigurer">
    <property name="parseSettings">
        <map>
            <entry key="validate-if-schema" value="false" value-type="java.lang.Boolean"/>
        </map>
    </property>
    <property name="serializeSettings">
        <map>
            <entry key="comments" value="false" value-type="java.lang.Boolean"/>
            <entry key="format-pretty-print" value="false" value-type="java.lang.Boolean"/>
        </map>
    </property>
</bean>
----

NOTE: This configuration is of global nature. All XML processing operations will be affected with this configuration.

[[groovy-xml-validation]]
=== Groovy XML validation

With the Groovy XmlSlurper you can easily validate XML message payloads without having to deal directly with XML. People
who do not want to deal with XPath may also like this validation alternative.

The tester directly navigates through the message elements and uses simple code assertions in order to control the message content.
Here is an example how to validate messages with Groovy script:

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(groovy().script("assert root.children().size() == 4\n" +
                              "assert root.MessageId.text() == '${messageId}'\n" +
                              "assert root.CorrelationId.text() == '${correlationId}'\n")
                              "assert root.Text.text() == 'Hello ' + context.getVariable(\"user\")"))
    .header("Operation, "sayHello")
    .header("CorrelationId", "${correlationId}")
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint" timeout="5000">
    <message>
        <validate>
            <script type="groovy">
                assert root.children().size() == 4
                assert root.MessageId.text() == '${messageId}'
                assert root.CorrelationId.text() == '${correlationId}'
                assert root.Text.text() == 'Hello ' + context.getVariable("user")
            </script>
        </validate>
    </message>
    <header>
        <element name="Operation" value="sayHello"/>
        <element name="CorrelationId" value="${correlationId}"/>
    </header>
</receive>
----

The Groovy XmlSlurper validation script goes right into the message-tag instead of a XML control template or XPath validation.
The Groovy script supports Java *_assert_* statements for message element validation. Citrus automatically injects the root
element *_root_* to the validation script. This is the Groovy XmlSlurper object and the start of element navigation. Based on
this root element you can access child elements and attributes with a dot notated syntax. Just use the element names separated
by a simple dot. Very easy! If you need the list of child elements use the *_children()_* function on any element. With the
*_text()_* function you get access to the element's text-value. The *_size()_* is very useful for validating the number of
child elements which completes the basic validation statements.

As you can see from the example, we may use test variables within the validation script, too. Citrus has also injected the
actual test context to the validation script. The test context object holds all test variables. So you can also access variables
with *_context.getVariable("user")_* for instance. On the test context you can also set new variable values with *_context.setVariable("user", "newUserName")_* .

There is even more object injection for the validation script. With the automatically added object *_receivedMessage_* You
have access to the Citrus message object for this receive action. This enables you to do whatever you want with the message
payload or header.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(groovy().script("assert receivedMessage.getPayload(String.class).contains(\"Hello Citrus!\")\n" +
                              "assert receivedMessage.getHeader("Operation") == 'sayHello'\n" +
                              "context.setVariable(\"request_payload\", receivedMessage.getPayload(String.class))"))
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint" timeout="5000">
    <message>
        <validate>
            <script type="groovy">
                assert receivedMessage.getPayload(String.class).contains("Hello Citrus!")
                assert receivedMessage.getHeader("Operation") == 'sayHello'

                context.setVariable("request_payload", receivedMessage.getPayload(String.class))
            </script>
        </validate>
    </message>
</receive>
----

The listing above shows some power of the validation script. We can access the message payload, we can access the message
header. With test context access we can also save the whole message payload as a new test variable for later usage in the test.

In general Groovy code inside the XML test case definition or as part of the Java DSL code is not very comfortable to maintain.
You do not have code syntax assist or code completion. This is why we can also use external file resources for the validation
scripts. The syntax looks like follows:

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(groovy()
            .script(new ClassPathResource("validationScript.groovy"))
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint" timeout="5000">
    <message>
        <validate>
            <script type="groovy" file="classpath:validationScript.groovy"/>
        </validate>
    </message>
</receive>
----

We referenced some external file resource *_validationScript.groovy_* . This file content is loaded at runtime and is used
as script body. Now that we have a normal groovy file we can use the code completion and syntax highlighting of our favorite
Groovy editor.

NOTE: You can use the Groovy validation script in combination with other validation types like XML tree comparison and XPath
validation.

TIP: For further information on the Groovy XmlSlurper please see the official Groovy website and documentation

[[xml-schema-validation]]
=== XML schema validation

There are several possibilities to describe the structure of XML documents. The two most popular ways are DTD
(Document type definition) and XSD (XML Schema definition). In case the XML document is classified using a
schema definition the structure of the document has to fit the predefined rules inside the schema definition.
XML document instances are valid only in case they meet all these structure rules defined in the schema definition.
Citrus can validate XML documents using the schema languages DTD and XSD.

[[xsd-schema-repositories]]
==== XSD schema repositories

Citrus tries to validate all incoming XML messages against a schema definition in order to ensure that all rules are
fulfilled. This means that the message receiving actions in Citrus have to know the XML schema definition file
resources that belong to our test context.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XsdSchemaRepository schemaRepository() {
    XsdSchemaRepository repository = new XsdSchemaRepository();
    repository.getSchemas().add(travelAgencySchema());
    repository.getSchemas().add(royalArilineSchema());
    repository.getSchemas().add(smartArilineSchema());
    return repository;
}

@Bean
public SimpleXsdSchema travelAgencySchema() {
    return new SimpleXsdSchema(
            new ClassPathResource("classpath:citrus/flightbooking/TravelAgencySchema.xsd"));
}

@Bean
public SimpleXsdSchema royalArilineSchema() {
    return new SimpleXsdSchema(
            new ClassPathResource("classpath:citrus/flightbooking/RoyalAirlineSchema.xsd"));
}

@Bean
public SimpleXsdSchema smartArilineSchema() {
    return new SimpleXsdSchema(
            new ClassPathResource("classpath:citrus/flightbooking/SmartAirlineSchema.xsd"));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema-repository id="schemaRepository">
    <citrus:schemas>
        <citrus:schema id="travelAgencySchema"
            location="classpath:citrus/flightbooking/TravelAgencySchema.xsd"/>
        <citrus:schema id="royalArilineSchema"
            location="classpath:citrus/flightbooking/RoyalAirlineSchema.xsd"/>
        <citrus:reference schema="smartArilineSchema"/>
    </citrus:schemas>
</citrus:schema-repository>

<citrus:schema id="smartArilineSchema"
      location="classpath:citrus/flightbooking/SmartAirlineSchema.xsd"/>
----

By convention there is a default schema repository component defined in the Citrus Spring application context with
the id *schemaRepository*. Spring application context is then able to inject the schema repository into all message
receiving test actions at runtime. The receiving test action consolidates the repository for a matching schema
definition file in order to validate the incoming XML document structure.

The connection between incoming XML messages and xsd schema files in the repository is done by a mapping strategy which
we will discuss later in this chapter. By default, Citrus picks the right schema based on the target namespace that is
defined inside the schema definition. The target namespace of the schema definition has to match the namespace of the
root element in the received XML message. With this mapping strategy you will not have to wire XML messages and schema
files manually all is done automatically by the Citrus schema repository at runtime. All you need to do is to register
all available schema definition files regardless of which target namespace or nature inside the Citrus schema
repository.

IMPORTANT: XML schema validation is mandatory in Citrus. This means that Citrus always tries to find a matching schema
definition inside the schema repository in order to perform syntax validation on incoming schema qualified XML messages.
A classified XML message is defined by its namespace definitions. Consequently you will get validation errors in case
no matching schema definition file is found inside the schema repository. So if you explicitly do not want to validate
the XML schema for some reason you have to disable the validation explicitly in your test with
*schema-validation="false"*.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .validate(xpath()
            .expression("//ns1:TestMessage/ns1:MessageHeader/ns1:MessageId", "${messageId}")
            .expression("//ns1:TestMessage/ns1:MessageHeader/ns1:CorrelationId", "${correlationId}")
            .schemaValidation(false)
            .namespaceContext("ns1", "http://citrus.com/namespace"))
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
    <message schema-validation="false">
      <validate>
        <xpath expression="//ns1:TestMessage/ns1:MessageHeader/ns1:MessageId"
             value="${messageId}"/>
        <xpath expression="//ns1:TestMessage/ns1:MessageHeader/ns1:CorrelationId"
             value="${correlationId}"/>
        <namespace prefix="ns1" value="http://citrus.com/namespace"/>
      </validate>
    </message>
</receive>
----

This mandatory schema validation might sound annoying to you but in our opinion it is very important to validate the
structure of the received XML messages, so disabling the schema validation should not be the standard for all tests.
Disabling automatic schema validation should only apply to very special situations. So please try to put all available
schema definitions to the schema repository and you will be fine.

[[wsdl-schemas]]
==== WSDL schemas

In SOAP WebServices world the WSDL (WebService Schema Definition Language) defines the structure an nature of the XML
messages exchanged across the interface. Often the WSDL files do hold the XML schema definitions as nested elements.
In Citrus you can directly set the WSDL file as location of a schema definition like this:

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public WsdlXsdSchema arilineWsdl() {
    return new WsdlXsdSchema(
            new ClassPathResource("classpath:citrus/flightbooking/AirlineSchema.wsdl"));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema id="arilineWsdl"
    location="classpath:citrus/flightbooking/AirlineSchema.wsdl"/>
----

Citrus is able to find the nested schema definitions inside the WSDL file in order to build a valid schema file for the
schema repository. So incoming XML messages that refer to the WSDL file can be validated for syntax rules.

[[schema-collections]]
==== Schema collections

Sometimes a XML schema definition is separated into multiple files. This is a problem for the Citrus schema repository
as the schema mapping strategy then is not able to pick the right file for validation, in particular when working with
target namespace values as key for the schema mapping strategy. As a solution for this problem you have to put all
schemas with the same target namespace value into a schema collection.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XsdSchemaCollection flightbookingSchemaCollection() {
    XsdSchemaCollection collection = new XsdSchemaCollection();
    collection.getSchemas().add("classpath:citrus/flightbooking/BaseTypes.xsd");
    collection.getSchemas().add("classpath:citrus/flightbooking/AirlineSchema.xsd");
    return collection;
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema-collection id="flightbookingSchemaCollection">
  <citrus:schemas>
    <citrus:schema location="classpath:citrus/flightbooking/BaseTypes.xsd"/>
    <citrus:schema location="classpath:citrus/flightbooking/AirlineSchema.xsd"/>
  </citrus:schemas>
</citrus:schema-collection>
----

Both schema definitions *BaseTypes.xsd* and *AirlineSchema.xsd* share the same target namespace and therefore need to
be combined in schema collection component. The schema collection can be referenced in any schema repository as normal
schema definition.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XsdSchemaRepository schemaRepository() {
    XsdSchemaRepository repository = new XsdSchemaRepository();
    repository.getSchemas().add(flightbookingSchemaCollection());
    return repository;
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema-repository id="schemaRepository">
  <citrus:schemas>
    <citrus:reference schema="flightbookingSchemaCollection"/>
  </citrus:schemas>
</citrus:schema-repository>
----

[[schema-mapping-strategy]]
==== Schema mapping strategy

The schema repository in Citrus holds one to many schema definition files and dynamically picks up the right one
according to the validated message payload. The repository needs to have some strategy for deciding which schema
definition to choose. See the following schema mapping strategies and decide which of them is suitable for you.

[[target-namespace-mapping-strategy]]
==== Target Namespace Mapping Strategy

This is the default schema mapping strategy. Schema definitions usually define some target namespace which is valid
for all elements and types inside the schema file. The target namespace is also used as root namespace in XML message
payloads. According to this information Citrus can pick up the right schema definition file in the schema repository.
You can set the schema mapping strategy as property in the configuration files:

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XsdSchemaRepository schemaRepository() {
    XsdSchemaRepository repository = new XsdSchemaRepository();
    repository.setSchemaMappingStrategy(schemaMappingStrategy());
    repository.getSchemas().add(helloSchema());
    return repository;
}

@Bean
public TargetNamespaceSchemaMappingStrategy schemaMappingStrategy() {
    return new TargetNamespaceSchemaMappingStrategy();
}

@Bean
public SimpleXsdSchema helloSchema() {
    return new SimpleXsdSchema(
            new ClassPathResource("classpath:citrus/samples/sayHello.xsd"));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema-repository id="schemaRepository"
    schema-mapping-strategy="schemaMappingStrategy">
  <citrus:schemas>
    <citrus:schema id="helloSchema"
        location="classpath:citrus/samples/sayHello.xsd"/>
  </citrus:schemas>
</citrus:schema-repository>

<bean id="schemaMappingStrategy"
    class="org.citrusframework.citrus.xml.schema.TargetNamespaceSchemaMappingStrategy"/>
----

The *sayHello.xsd* schema file defines a target namespace (http://consol.de/schemas/sayHello.xsd)[http://consol.de/schemas/sayHello.xsd)]:

.Schema target namespace
[source,xml]
----
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns="http://consol.de/schemas/sayHello.xsd"
    targetNamespace="http://consol.de/schemas/sayHello.xsd"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified">

</xs:schema>
----

Incoming request messages should also have the target namespace set in the root element and this is how Citrus matches
the right schema file in the repository.

.HelloRequest.xml
[source,xml]
----
<HelloRequest xmlns="http://consol.de/schemas/sayHello.xsd">
   <MessageId>123456789</MessageId>
   <CorrelationId>1000</CorrelationId>
   <User>Christoph</User>
   <Text>Hello Citrus</Text>
</HelloRequest>
----

[[root-qname-mapping-strategy]]
==== Root QName Mapping Strategy

The next possibility for mapping incoming request messages to a schema definition is via the XML root element QName.
Each XML message payload starts with a root element that usually declares the type of a XML message. According to this
root element you can set up mappings in the schema repository.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XsdSchemaRepository schemaRepository() {
    XsdSchemaRepository repository = new XsdSchemaRepository();
    repository.setSchemaMappingStrategy(schemaMappingStrategy());
    repository.getSchemas().add(helloSchema());
    repository.getSchemas().add(goodbyeSchema());
    return repository;
}

@Bean
public RootQNameSchemaMappingStrategy schemaMappingStrategy() {
    RootQNameSchemaMappingStrategy rootQnameStrategy = new RootQNameSchemaMappingStrategy();
    rootQnameStrategy.getMappings().put("HelloRequest", helloSchema());
    rootQnameStrategy.getMappings().put("GoodbyeRequest", goodbyeSchema());

    return rootQnameStrategy;
}

@Bean
public SimpleXsdSchema helloSchema() {
    return new SimpleXsdSchema(
            new ClassPathResource("classpath:citrus/samples/sayHello.xsd"));
}

@Bean
public SimpleXsdSchema goodbyeSchema() {
    return new SimpleXsdSchema(
            new ClassPathResource("classpath:citrus/samples/sayGoodbye.xsd"));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema-repository id="schemaRepository"
    schema-mapping-strategy="schemaMappingStrategy">
  <citrus:schemas>
    <citrus:reference schema="helloSchema"/>
    <citrus:reference schema="goodbyeSchema"/>
  </citrus:schemas>
</citrus:schema-repository>

<bean id="schemaMappingStrategy"
    class="org.citrusframework.citrus.xml.schema.RootQNameSchemaMappingStrategy">
  <property name="mappings">
    <map>
      <entry key="HelloRequest" value="helloSchema"/>
      <entry key="GoodbyeRequest" value="goodbyeSchema"/>
    </map>
  </property>
</bean>

<citrus:schema id="helloSchema"
    location="classpath:citrus/samples/sayHello.xsd"/>

<citrus:schema id="goodbyeSchema"
     location="classpath:citrus/samples/sayGoodbye.xsd"/>
----

The listing above defines two root qname mappings - one for *HelloRequest* and one for *GoodbyeRequest* message types.
An incoming message of type <HelloRequest> is then mapped to the respective schema and so on. With this dedicated
mappings you are able to control which schema is used on a XML request, regardless of target namespace definitions.

[[schema-mapping-strategy-chain]]
==== Schema mapping strategy chain

Let's discuss the possibility to combine several schema mapping strategies in a logical chain. You can define more than
one mapping strategy that are evaluated in sequence. The first strategy to find a proper schema definition file in the
repository wins.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XsdSchemaRepository schemaRepository() {
    XsdSchemaRepository repository = new XsdSchemaRepository();
    repository.setSchemaMappingStrategy(schemaMappingStrategy());
    repository.getSchemas().add(helloSchema());
    repository.getSchemas().add(goodbyeSchema());
    return repository;
}

@Bean
public SchemaMappingStrategyChain schemaMappingStrategy() {
    SchemaMappingStrategyChain chain = new SchemaMappingStrategyChain();

    RootQNameSchemaMappingStrategy rootQnameStrategy = new RootQNameSchemaMappingStrategy();
    rootQnameStrategy.getMappings().put("HelloRequest", helloSchema());

    chain.setStrategies(Arrays.asList(
        rootQnameStrategy,
        new TargetNamespaceSchemaMappingStrategy()
    ));

    return chain;
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<citrus:schema-repository id="schemaRepository"
    schema-mapping-strategy="schemaMappingStrategy">
  <citrus:schemas>
    <citrus:reference schema="helloSchema"/>
    <citrus:reference schema="goodbyeSchema"/>
  </citrus:schemas>
</citrus:schema-repository>

<bean id="schemaMappingStrategy"
    class="org.citrusframework.citrus.xml.schema.SchemaMappingStrategyChain">
  <property name="strategies">
    <list>
      <bean class="org.citrusframework.citrus.xml.schema.RootQNameSchemaMappingStrategy">
        <property name="mappings">
          <map>
            <entry key="HelloRequest" value="helloSchema"/>
          </map>
        </property>
      </bean>
      <bean class="org.citrusframework.citrus.xml.schema.TargetNamespaceSchemaMappingStrategy"/>
    </list>
  </property>
</bean>
----

So the schema mapping chain uses both *RootQNameSchemaMappingStrategy* and *TargetNamespaceSchemaMappingStrategy* in
combination. In case the first root qname strategy fails to find a proper mapping the next target namespace strategy
comes in and tries to find a proper schema.

[[dtd-validation]]
==== DTD validation

XML DTD (document type definition) is another way to validate the structure of a XML document. Many people say that
DTD is deprecated and XML schema is the much more efficient way to describe the rules of a XML structure. We do not
disagree with that, but we also know that legacy systems might still use DTD. So in order to avoid validation errors
we have to deal with DTD validation as well.

First thing you can do about DTD validation is to specify an inline DTD in your expected message template.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .body("<!DOCTYPE root [\n" +
                "<!ELEMENT root (message)>\n" +
                "<!ELEMENT message (text)>\n" +
                "<!ELEMENT text (#PCDATA)>\n" +
            "]>\n" +
            "<root>\n" +
                "<message>\n" +
                    "<text>Hello from Citrus!</text>\n" +
                "</message>\n" +
            "</root>")
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
    <message schema-validation="false">
        <data>
        <![CDATA[
            <!DOCTYPE root [
                <!ELEMENT root (message)>
                <!ELEMENT message (text)>
                <!ELEMENT text (#PCDATA)>
                ]>
            <root>
                <message>
                    <text>Hello from Citrus!</text>
                </message>
            </root>
        ]]>
        </data>
    </message>
</receive>
----

The system under test may also send the message with a inline DTD definition. So validation will succeed.

In most cases the DTD is referenced as external .dtd file resource. You can do this in your expected message template
as well.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .body("<!DOCTYPE root SYSTEM \"org/citrusframework/citrus/validation/example.dtd\">\n" +
            "<root>\n" +
                "<message>\n" +
                    "<text>Hello from Citrus!</text>\n" +
                "</message>\n" +
            "</root>")
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
    <message schema-validation="false">
        <data>
        <![CDATA[
            <!DOCTYPE root SYSTEM "org/citrusframework/citrus/validation/example.dtd">
            <root>
                <message>
                    <text>Hello from Citrus!</text>
                </message>
            </root>
        ]]>
        <data/>
    </message>
</receive>
----

[[xml-validation-xhtml]]
=== XHTML validation

Html message content is hard to verify with XML validation capabilities such as XML tree comparison or XPath support.
Usually Html messages do not follow the XML well-formed rules very strictly. This implies that XML message validation will
fail because of non-well-formed Html code.

XHTML closes this gap by automatically fixing the most common Html XML incompatible rule violations such as missing end
tags (e.g. <br>).

Please add a new library dependency to your project. Citrus is using the *jtidy* library in order to prepare the HTML and
XHTML messages for validation. As this 3rd party dependency is optional in Citrus we have to add it now to our project dependency
list. Just add the *jtidy* dependency to your Maven project POM.

.Jtidy library
[source,xml]
----
<dependency>
    <groupId>net.sf.jtidy</groupId>
    <artifactId>jtidy</artifactId>
    <version>r938</version>
  </dependency>
----

Please refer to the *jtidy* project documentation for the latest versions. Now everything is ready. As usual the Citrus
message validator for XHTML is active in background by default. You can overwrite this default implementation by placing
a Spring bean with id *defaultXhtmlMessageValidator* to the Citrus application context.

.Java
[source,java,indent=0,role="primary"]
----
@Bean
public XhtmlMessageValidator defaultXhtmlMessageValidator() {
    return new XhtmlMessageValidator();
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<bean id="defaultXhtmlMessageValidator" class="org.citrusframework.citrus.validation.xhtml.XhtmlMessageValidator"/>
----

Now you can use the XHTML message validation in your test case.

.Java
[source,java,indent=0,role="primary"]
----
receive("someEndpoint")
    .message()
    .type(MessageType.XHTML)
    .body("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"org/w3c/xhtml/xhtml1-strict.dtd\">" +
            "<html xmlns=\"http://www.w3.org/1999/xhtml\">" +
                "<head>" +
                    "<title>Citrus Hello World</title>" +
                "</head>" +
                "<body>" +
                    "<h1>Hello World!</h1>" +
                    "<br/>" +
                    "<p>This is a test!</p>" +
                "</body>" +
            "</html>")
    .timeout(5000L);
----

.XML
[source,xml,indent=0,role="secondary"]
----
<receive endpoint="someEndpoint">
    <message type="xhtml">
        <data>
          <![CDATA[
            <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "org/w3c/xhtml/xhtml1-strict.dtd">
            <html xmlns="http://www.w3.org/1999/xhtml">
              <head>
                <title>Citrus Hello World</title>
              </head>
              <body>
                <h1>Hello World!</h1>
                <br/>
                <p>This is a test!</p>
              </body>
            </html>
          ]]>
        </data>
    </message>
</receive>
----

The message receiving action in our test case has to specify a message format type *type="xhtml"* . As you can see the Html
message payload get XHTML specific DOCTYPE processing instruction. The *xhtml1-strict.dtd* is mandatory in the XHTML message
validation. For better convenience all XHTML dtd files are packaged within Citrus so you can use this as a relative path.

The incoming Html message is automatically converted into proper XHTML code with well formed XML. So now the XHTML message
validator can use the XML message validation mechanism of Citrus for comparing received and expected data. You can also use
test variables, ignore element expressions and XPath expressions.
