[[openapi]]
== OpenAPI support

https://www.openapis.org/[OpenAPI] is a popular specification language to describe HTTP APIs and its exposure to clients.
Citrus is able to leverage the specification to auto generate client and server request/response message data.
The generated message data follows the rules of a given operation in the specification.
In particular, the message body is generated from the given Json schema rules in that specification.
This way users may do contract-driven testing where the client and the server ensure the conformity with the contract to obey to the same specification rules.

NOTE: The OpenAPI support in Citrus get enabled by adding a separate Maven module as dependency to your project

[source,xml]
----
<dependency>
  <groupId>org.citrusframework</groupId>
  <artifactId>citrus-openapi</artifactId>
  <version>${citrus.version}</version>
</dependency>
----

[[openapi-specification]]
=== OpenAPI specification

The OpenAPI test actions in Citrus uses a specification which usually is a json or yaml document shared between the components.

Sometimes the specification gets exposed by a server application via HTTP endpoint.
You can directly load the specification from the HTTP URL.
Or you may just point the OpenAPI components to a local specification file.

Citrus supports OpenAPI on both client and server components so the next sections will describe the usage for each of those.

[[openapi-client]]
=== OpenAPI client

On the client side Citrus uses the OpenAPI specification to generate a proper HTTP request that is sent to the server.
The user just gives a valid operationId from the specification every thing else is automatically generated.
The Citrus client message will use the proper request path (e.g. `/petstore/v3/pet`) and Content-Type (e.g. `applicaiton/json`) according to the specification rules.

Of course, you can also validate the HTTP response message with auto generated validation.
The user just gives the expected HTTP status code that is also described in the specification (e.g. 200 OK).
The response data used as expected message content is then also generated from the specification.

As an example the following OpenAPI specification defines the operation `getPetById`.

.petstore-v3.yaml
[source,yaml]
----
openapi: 3.0.2
info:
  title: Petstore
  version: 1.0.1
servers:
  - url: 'http://localhost/petstore/v3/'
paths:
  '/pet/{petId}':
    get:
      operationId: getPetById
      parameters:
        - name: petId
          description: ID of pet to return
          schema:
            format: int64
            type: integer
          in: path
          required: true
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Pet'
        '404':
          description: Pet not found
      summary: Find pet by ID
      description: Returns a single pet
# ...
----

The operation defines the HTTP GET request on `/pet/{petId}` and the response `200` OK that delivers the `#/components/schemas/Pet` Json object to the calling client as a response.

The Json schema for the pet defines all properties on the object.

.Pet Json schema
[source,yaml]
----
Pet:
  required:
    - category
    - name
    - status
  type: object
  properties:
    id:
      format: int64
      type: integer
    category:
      $ref: '#/components/schemas/Category'
    name:
      type: string
      example: doggie
    photoUrls:
      type: array
      items:
        type: string
    tags:
      type: array
      items:
        $ref: '#/components/schemas/Tag'
    status:
      description: pet status in the store
      enum:
        - available
        - pending
        - sold
      type: string
# ...
----

In a testcase Citrus is able to leverage this information in order to send a proper request and validate the response based on the OpenAPI specification.

.Java
[source,java,indent=0,role="primary"]
----
private final HttpClient httpClient = new HttpClientBuilder()
            .requestUrl("http://localhost:%d".formatted(port))
            .build();

private final OpenApiSpecification petstoreSpec = OpenApiSpecification.from(
            Resources.create("classpath:org/citrusframework/openapi/petstore/petstore-v3.json"));

@CitrusTest
public void openApiClientTest() {
    // Define variables to set request parameters.
    // Note that the path-param in `petstore-v3.yaml` is named `petId`
    variable("petId", "1001");
    when(openapi(petstoreSpec)
                .client(httpClient)
                .send("getPetById"));

    then(openapi(petstoreSpec)
                .client(httpClient)
                .receive("getPetById", HttpStatus.OK));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<test name="OpenApiClientTest" xmlns="http://citrusframework.org/schema/xml/testcase">
    <variables>
        <variable name="petstoreSpec" value="classpath:org/citrusframework/openapi/petstore/petstore-v3.json"/>
        <!-- Define variables to set request parameters.
             Note that the path-param in `petstore-v3.yaml` is named `petId` -->
        <variable name="petId" value="1001"/>
    </variables>
    <actions>
        <openapi specification="${petstoreSpec}" client="httpClient">
          <send-request operation="getPetById"/>
        </openapi>

        <openapi specification="${petstoreSpec}" client="httpClient">
          <receive-response operation="getPetById" status="200"/>
        </openapi>
    </actions>
</test>
----

.YAML
[source,yaml,indent=0,role="secondary"]
----
name: OpenApiClientTest
variables:
  - name: petstoreSpec
    value: classpath:org/citrusframework/openapi/petstore/petstore-v3.yaml
actions:
  - openapi:
      specification: ${petstoreSpec}
      client: "httpClient"
      sendRequest:
        operation: getPetById
  - openapi:
      specification: ${petstoreSpec}
      client: "httpClient"
      receiveResponse:
        operation: getPetById
        status: 200
----

.Spring XML
[source,xml,indent=0,role="secondary"]
----
<spring:beans xmlns="http://www.citrusframework.org/schema/testcase"
              xmlns:spring="http://www.springframework.org/schema/beans">
    <!-- NOT SUPPORTED -->
</spring:beans>
----

In this very first example The client uses the OpenAPI specification to generate a proper GET HTTP request for the `getPetById` operation.
The request is sent to the server using the request URL path `/petstore/v3/pet/${petId}` as declared in the OpenAPI specification.

The resulting HTTP response from the server is verified on the client by giving the operationId and the expected status `200`.
The OpenAPI client generates the expected control message from the given Json schema in the OpenAPI specification.

The generated control message contains validation matchers and expressions as follows.

.Generated control message body
[source,json]
----
{
  "id": "@isNumber()@",
  "name": "@notEmpty()@",
  "category": {
    "id": "@isNumber()@",
    "name": "@notEmpty()@"
  },
  "photoUrls": "@notEmpty()@",
  "tags":  "@ignore@",
  "status": "@matches(sold|pending|available)@"
}
----

This control message meets the rules defined by the OpenAPI Json schema specification for the pet object.
For instance the enum field `status` is validated with a matching expression.
In case the OpenAPI specification changes the generated control message will change accordingly.

This completes the client side OpenAPI support.
Now let's have a closer look at the server side OpenAPI support in the next section.

[[openapi-server]]
=== OpenAPI server

On the server side Citrus is able to verify incoming requests based on the OpenAPI specification.
The expected request message content as well as the expected resource URL path and the Content-Type are automatically validated.

.Java
[source,java,indent=0,role="primary"]
----
private final HttpServer httpServer = new HttpServerBuilder()
            .port(port)
            .timeout(5000L)
            .autoStart(true)
            .defaultStatus(HttpStatus.NO_CONTENT)
            .build();

private final OpenApiSpecification petstoreSpec = OpenApiSpecification.from(
            Resources.create("classpath:org/citrusframework/openapi/petstore/petstore-v3.json"));

@CitrusTest
public void openApiClientTest() {
    // Define variables to set request parameters.
    // Note that the path-param in `petstore-v3.yaml` is named `petId`
    variable("petId", "1001");
    when(openapi(petstoreSpec)
                .server(httpServer)
                .receive("addPet"));

    then(openapi(petstoreSpec)
                .server(httpServer)
                .send("addPet", HttpStatus.CREATED));
}
----

.XML
[source,xml,indent=0,role="secondary"]
----
<test name="OpenApiClientTest" xmlns="http://citrusframework.org/schema/xml/testcase">
    <variables>
        <variable name="petstoreSpec" value="classpath:org/citrusframework/openapi/petstore/petstore-v3.json"/>
        <!-- Define variables to set request parameters.
             Note that the path-param in `petstore-v3.yaml` is named `petId` -->
        <variable name="petId" value="1001"/>
    </variables>
    <actions>
        <openapi specification="${petstoreSpec}" server="httpServer">
          <receive-request operation="addPet"/>
        </openapi>

        <openapi specification="${petstoreSpec}" server="httpServer">
          <send-response operation="addPet" status="200"/>
        </openapi>
    </actions>
</test>
----

.YAML
[source,yaml,indent=0,role="secondary"]
----
name: OpenApiClientTest
variables:
  - name: petstoreSpec
    value: classpath:org/citrusframework/openapi/petstore/petstore-v3.yaml
actions:
  - openapi:
      specification: ${petstoreSpec}
      server: "httpServer"
      receiveRequest:
        operation: addPet
  - openapi:
      specification: ${petstoreSpec}
      server: "httpServer"
      sendResponse:
        operation: addPet
        status: 200
----

.Spring XML
[source,xml,indent=0,role="secondary"]
----
<spring:beans xmlns="http://www.citrusframework.org/schema/testcase"
              xmlns:spring="http://www.springframework.org/schema/beans">
    <!-- NOT SUPPORTED -->
</spring:beans>
----

The example above uses the `addPet` operation defined in the OpenAPI specification.
The operation expects a HTTP POST request with a pet object as message payload.
The OpenAPI server generates an expected Json message body according to the specification.
This ensures that the incoming client request meets the Json schema rules for the pet object.
Also, the server will verify the HTTP request method, the Content-Type header as well as the used resource path `/petstore/v3/pet`.

The given HTTP status code defines the response that should be sent by the server.
The server will generate a proper response according to the OpenAPI specification.
This also includes a potential response message body (e.g. pet object).

[[openapi-test-api-generator]]
=== OpenAPI Test API Generator

For an even deeper integration with a given OpenAPI, Citrus offers the possibility to generate a dedicated Test API which provides test actions tailored to the specific operations of the OpenAPI under evaluation.
These actions can be used in XML or Java DSL.
The functionality is provided by the `Citrus OpenAPI Test API Generator` which  leverages the link:https://github.com/swagger-api/swagger-codegen/tree/master[OpenAPI Code Generator] to generate code, but provides custom templates tailored for seamless integration within the Citrus framework.

The generator provides the following features:

* generation of a Test API
** from OpenAPI Specification
** [TODO #1163] from WSDL via an intermediate step that generates a "light" OpenApi specification from a WSDL
* integration into <<run-xml-tests,Citrus XML test cases>>
** integration into XML editors via generated XSD
*** schema validation
*** auto completion
* integration into <<run-java,Citrus Java test cases>> via Java DSL [TODO #1161]

The following directory structure/table specifies the files, which are generated by the generator.
Note that the `Prefix` is a configuration parameter which should uniquely identify a generated API.
It is specified in the build configuration for the Test API.

.Generated Folder Structure
[source]
----
target/
├───generated-test-resources/
│   ├───META-INF/
│   │   ├───spring.handlers
│   │   └───spring.schemas
│   └───schema/
│       └───xsd/
│           └───prefix-api.xsd
└───generated-test-sources/
    └───org/
        └───citrusframework/
            └───automation/
                └───prefix/
                    ├───api/
                    │   └───MyApi.java
                    ├───citrus/
                    │   ├───extension/
                    │   │   └───PrefixNamespaceHandler.java
                    │   ├───PrefixAbstractTestRequest.java
                    │   └───PrefixBeanDefinitionParser.java
                    ├───model/
                    │   ├───MyReqTypeA.java
                    │   └───MyReqTypeB.java
                    └───spring/
                        └───PrefixBeanConfiguration.java
----

|===
| File                                | Content

| `spring.handlers`                   | Spring namespace handler configuration, that contains all NamespaceHandlers for all generated APIs.
| `spring.schemas`                    | Spring schema definitions, with mappings of namespaces to schemas for all generated APIs.
| `prefix-api.xsd`                    | XSD schema for the integration of the Test API into XML.
| `PrefixNamespaceHandler.java`       | A Spring class, that registers bean definition parsers for Test API XML elements.
| `PrefixAbstractTestRequest.java`    | Abstract superclass of all Test API actions.
| `PrefixBeanDefinitionParser.java`   | Spring bean definition parser, responsible for parsing Test API XML elements into test actions.
| `MyReqTypeA.java, MyReqTypeB.java`  | Model files generated with respect to the schema definition of the OpenAPI.
| `PrefixBeanConfiguration.java`      | A Spring @Configuration class, that registers all Test API actions as Spring beans.
|===

==== Configuration of Test API Generation

Code generation is typically performed during the build process.
For the Citrus Test API Generator, it is carried out by a Maven or Gradle plugin.
While the standard generator plugin, `org.openapitools:openapi-generator-maven-plugin`, can be employed for this purpose, configuring it can be cumbersome, especially when dealing with multiple APIs.
To address this challenge, Citrus offers its own adaptation of this standard generator plugin.
This `Citrus OpenAPI Generator Plugin` simplifies the configuration of test API generation by providing predefined defaults and supporting the generation of multiple APIs.
Additionally, it enhances support for generating Spring integration files (`spring.handlers` and `spring.schemas`), as described above.
It is thereby facilitating the integration of generated APIs into Spring-based applications.
Consequently, utilizing the Citrus Generator Plugin is recommended in most scenarios.

The following shows the configuration of test api generation for different scenarios:

.Citrus OpenAPI Generator Plugin - multiple APIs, minimal configuration
[source,xml,indent=0,role="primary"]
----
<plugin>
    <artifactId>citrus-test-api-generator-maven-plugin</artifactId>
    <configuration>
        <!-- Configuration for multiple APIs, with the minimal set of configurations per api.
        Defaults will be assigned as described in the Configuration Options section. -->
        <apis>
            <api>
                <prefix>Multi1</prefix>
                <source>api/test-api.yml</source>
            </api>
            <api>
                <prefix>Multi2</prefix>
                <source>api/test-api.yml</source>
            </api>
            <api>
                <prefix>Multi3</prefix>
                <source>api/test-api.yml</source>
            </api>
        </apis>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>create-test-api</goal>
            </goals>
        </execution>
    </executions>
</plugin>

----

.Citrus OpenAPI Generator Plugin - single API full configuration
[source,xml,indent=0,role="secondary"]
----
<plugin>
    <artifactId>citrus-test-api-generator-maven-plugin</artifactId>
    <configuration>
        <!-- Configuration for Single APIs, with the full set of configuration. -->
        <apis>
            <sourceFolder>my-generated-sources</sourceFolder>
            <resourceFolder>my-generated-resources</resourceFolder>
            <schemaFolder>myschema/xsd</schemaFolder>
            <metaInfFolder>src/main/resources/META-INF</metaInfFolder>
            <api>
                <prefix>Full</prefix>
                <source>api/test-api.yml</source>
                <apiPackage>org.mypackage.%PREFIX%.api</apiPackage>
                <endpoint>myEndpoint</endpoint>
                <invokerPackage>org.mypackage.%PREFIX%.invoker</invokerPackage>
                <modelPackage>org.mypackage.%PREFIX%.model</modelPackage>
                <targetXmlnsNamespace>"http://company/citrus-test-api/myNamespace"
                </targetXmlnsNamespace>
            </api>
        </apis>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>create-test-api</goal>
            </goals>
        </execution>
    </executions>
</plugin>
----

.Standard OpenAPI Generator Plugin
[source,xml,indent=0,role="secondary"]
----
<!-- for detailed information refer to pom.xml of citrus-test-api-generator-core -->
<plugin>
    <groupId>org.openapitools</groupId>
    <artifactId>openapi-generator-maven-plugin</artifactId>
    <!-- Add the citrus generator as dependency -->
    <dependencies>
        <dependency>
            <groupId>org.citrusframework</groupId>
            <artifactId>citrus-test-api-generator-core</artifactId>
            <version>${project.version}</version>
        </dependency>
    </dependencies>
    <configuration>
        <configOptions>
            <apiType>REST</apiType>
            <resourceFolder>generated-test-resources</resourceFolder>
            <sourceFolder>generated-test-sources</sourceFolder>
            <useTags>true</useTags>
        </configOptions>
        <generateSupportingFiles>true</generateSupportingFiles>
        <!-- Use citrus generator for generation -->
        <generatorName>java-citrus</generatorName>
        <output>${project.build.directory}</output>
    </configuration>
    <executions>
        <execution>
            <id>generate-openapi-petstore-files</id>
            <phase>compile</phase>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <inputSpec>${project.basedir}/src/test/resources/apis/petstore.yaml</inputSpec>
                <configOptions>
                    <invokerPackage>org.citrusframework.openapi.generator.rest.petstore</invokerPackage>
                    <apiPackage>org.citrusframework.openapi.generator.rest.petstore.request</apiPackage>
                    <modelPackage>org.citrusframework.openapi.generator.rest.petstore.model</modelPackage>
                    <prefix>PetStore</prefix>
                    <apiEndpoint>petStoreEndpoint</apiEndpoint>
                </configOptions>
            </configuration>
        </execution>
        <execution>
            <id>generate-openapi-files-for-soap</id>
            <phase>compile</phase>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <inputSpec>${project.basedir}/src/test/resources/org/citrusframework/openapi/generator/SimpleWsdlToOpenApiTransformerTest/BookService-generated.yaml</inputSpec>
                <configOptions>
                    <apiType>SOAP</apiType>
                    <invokerPackage>org.citrusframework.openapi.generator.soap.bookservice</invokerPackage>
                    <apiPackage>org.citrusframework.openapi.generator.soap.bookservice.request</apiPackage>
                    <modelPackage>org.citrusframework.openapi.generator.soap.bookservice.model</modelPackage>
                    <prefix>SoapSample</prefix>
                    <prefix>OpenApiFromWsdl</prefix>
                    <apiEndpoint>soapSampleEndpoint</apiEndpoint>
                </configOptions>
            </configuration>
        </execution>
    </executions>
</plugin>
----

These are the primary elements you can configure in the `<configuration>` section:

|===
| Configuration element            | Maven Property                                                | Description                                                      | Default Value

| `schemaFolder`                   | `citrus.test.api.generator.schema.folder`                     | Location of the generated XSD schemas                            | `schema/xsd/%VERSION%`
| `resourceFolder`                 | `citrus.test.api.generator.resource.folder`                   | Location into which the resources are generated                  | `generated-resources`
| `sourceFolder`                   | `citrus.test.api.generator.source.folder`                     | Location into which the sources are generated                    | `generated-sources`
| `metaInfFolder`                  | `citrus.test.api.generator.meta.inf.folder`                   | Location into which spring meta files are generated/updated      | `target/generated-test-resources/META-INF`
| `generateSpringIntegrationFiles` | `citrus.test.api.generator.generate.spring.integration.files` | Specifies whether spring integration files should be generated   | `true`
| Nested `<api />` element         |                                                               |                                                                  |
| `prefix`                         | `citrus.test.api.generator.prefix`                            | Specifies the prefix used for the test API, typically an acronym | (no default, **required**)
| `source`                         | `citrus.test.api.generator.source`                            | Specifies the source of the test API                             | (no default, **required**)
| `version`                        | `citrus.test.api.generator.version`                           | Specifies the version of the API, may be `null`                  | (none)
| `endpoint`                       | `citrus.test.api.generator.endpoint`                          | Specifies the endpoint of the test API                           | `applicationServiceClient`
| `type`                           | `citrus.test.api.generator.type`                              | Specifies the type of the test API                               | `REST`, other option is `SOAP`
| `useTags`                        | `citrus.test.api.generator.use.tags`                          | Specifies whether tags should be used by the generator           | `true`
| `invokerPackage`                 | `citrus.test.api.generator.invoker.package`                   | Package for the test API classes                                 | `org.citrusframework.automation.%PREFIX%.%VERSION%`
| `apiPackage`                     | `citrus.test.api.generator.api.package`                       | Package for the test API interface classes                       | `org.citrusframework.automation.%PREFIX%.%VERSION%.api`
| `modelPackage`                   | `citrus.test.api.generator.model.package`                     | Package for the test API model classes                           | `org.citrusframework.automation.%PREFIX%.%VERSION%.model`
| `targetXmlnsNamespace`           | `citrus.test.api.generator.namespace`                         | XML namespace used by the API                                    | `http://www.citrusframework.org/schema/%VERSION%/%PREFIX%-api`
|===

Note: `%PREFIX%` and `%VERSION%` are placeholders that will be replaced by their specific values as configured.
The plugin performs a conversion to lowercase for `PREFIX` used in package names and in `targetXmlnsNamespace`.

==== Running the generator

To run the generator, execute the following command in your project directory:

[source,bash]
----
mvn citrus-test-api-generator-maven-plugin:create-test-api
----

This command will generate the classes and XSD files as configured for your APIs in the specified locations.

==== Spring meta file generation

The `citrus-test-api-generator-maven-plugin` supports the generation of Spring integration files, specifically `spring.handlers` and `spring.schemas`.
These files are essential for Spring applications utilizing XML configuration.
The generated Spring integration files serve the purpose of mapping custom XML namespaces to their corresponding namespace handler and schema locations.
This mapping allows Spring to properly parse and validate XML configuration files containing custom elements and attributes.

===== Configuration

The maven plugin generates these Spring integration files based on the provided configuration in the `citrus-test-api-generator-maven-plugin` section of the `pom.xml` file.
For each API specified, the plugin writes entries into the `spring.handlers` and `spring.schemas` files according to the configured XML namespaces and their corresponding handlers and schemas.

===== Important Consideration

When there are other non-generated Spring schemas or handlers present in the `META-INF` folder, it's crucial to ensure that the `metaInfFolder` configuration points to the existing `META-INF` directory in the main resources, which is usually `src/main/resources/META-INF`.
This ensures that the plugin correctly updates the existing files without overwriting them.

To identify generated schemas, their namespace should include the following segment `citrus-test-schema`.
During updates of the meta files, the generator filters out lines containing this segment from existing files and then re-adds them, preserving any non-generated content.

==== Usage

Once generated, the `spring.handlers` and `spring.schemas` files, along with any existing non-generated content, should be included in the resources of your Spring application.
During runtime, Spring will use these files to resolve custom XML namespaces and handle elements accordingly.
This automatically happens if one of the following folders is chosen:

-   `target/generated-test-resources/META-INF` (default)
-   `target/generated-resources/META-INF` for pure testing projects that provide their code on main rather than test
-   `src/main/resources/META-INF` - for mixing existing meta files with generated

==== Configuration of the Test Classpath

In case you choose to generate the API into `generated-test` folders, the maven build requires further configuration to add the `generated-test` folders to the classpath.
The link:https://www.mojohaus.org/build-helper-maven-plugin/usage.html[build-helper-maven-plugin] is used to accomplish this configuration step.

.Configuration of `build-helper-maven-plugin`
[source,xml]
----
<build>
   <plugins>
      <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>build-helper-maven-plugin</artifactId>
         <executions>
            <execution>
               <id>add-test-sources</id>
               <phase>generate-test-sources</phase>
               <goals>
                  <goal>add-test-source</goal>
               </goals>
               <configuration>
                  <sources>
                     <source>${project.build.directory}/generated-test-sources</source>
                  </sources>
               </configuration>
            </execution>
            <execution>
               <id>add-test-resource</id>
               <phase>generate-test-resources</phase>
               <goals>
                  <goal>add-test-resource</goal>
               </goals>
               <configuration>
                  <resources>
                     <resource>
                        <directory>${project.build.directory}/generated-test-resources</directory>
                     </resource>
                  </resources>
               </configuration>
            </execution>
         </executions>
      </plugin>
   </plugins>
</build>
----

==== Sample usage

To utilize the test API in XML, it's necessary to import the respective namespace.
Once imported, requests can be directly employed as actions, as illustrated in the sample below.
Further examples can be found here `org.citrusframework.openapi.generator.GeneratedApiIT`.

.XML DSL
[source,xml,indent=0,role="secondary"]
----
<spring:beans
    xmlns="http://www.citrusframework.org/schema/testcase"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:spring="http://www.springframework.org/schema/beans"
    xmlns:petstore="http://www.citrusframework.org/citrus-test-schema/petstore-api"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.citrusframework.org/schema/testcase
    http://www.citrusframework.org/schema/testcase/citrus-testcase.xsd
    http://www.citrusframework.org/citrus-test-schema/petstore-api
    http://www.citrusframework.org/citrus-test-schema/petstore-api/petstore-api.xsd"
>
    <testcase name="defaultOas3SchemaValidationTest">
        <actions>
            <petstore:getPetByIdRequest petId="1234">
                <petstore:response>
                    <petstore:json-path value="Snoopy" expression="$.name" />
                    <petstore:json-path value="12" expression="$.id" />
                </petstore:response>
            </petstore:getPetByIdRequest>
        </actions>
    </testcase>
</spring:beans>
----

To utilize the test API in Java, it's necessary to import the API configuration, that provides the respective request actions.
The request to test can then be configured and autowired, as illustrated in the sample below.
Further examples can be found here: `org.citrusframework.openapi.generator.GetPetByIdIT`.

.Java DSL
[source,java,indent=0,role="secondary"]
----
@ExtendWith(CitrusSpringExtension.class)
@SpringBootTest(classes = {PetStoreBeanConfiguration.class, CitrusSpringConfig.class})
class GetPetByIdTest {

    @Autowired
    private ApplicationContext applicationContext;

    @Autowired
    private GetPetByIdRequest getPetByIdRequest;

    @Test
    @CitrusTest
    void testByJsonPath(@CitrusResource TestCaseRunner runner) {

        // Given
        getPetByIdRequest.setPetId("1234");

        // Then
        getPetByIdRequest.setResponseStatus(HttpStatus.OK.value());
        getPetByIdRequest.setResponseReasonPhrase(HttpStatus.OK.getReasonPhrase());

        // Assert body by json path
        getPetByIdRequest.setResponseValue(Map.of("$.name", "Snoopy"));

        // When
        runner.$(getPetByIdRequest);
    }
}
----
